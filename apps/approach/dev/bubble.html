<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>D3 Drag Blob Edges (No Jump)</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
      body {
        margin: 0;
        padding: 0;
        background: #fafafa;
        font-family: sans-serif;
      }
      svg {
        display: block;
        margin: 0 auto;
        border: 1px solid #ccc;
        background-color: #fff;
      }
      .anchor {
        cursor: pointer;
        fill: #fff;
        stroke: #000;
        stroke-width: 1px;
      }
      .node path {
        cursor: move;
      }
    </style>
  </head>
  <body>
    <svg id="viz" width="800" height="600"></svg>

    <script>
      const data = d3.range(3).map((_, i) => {
        const baseR = 30 + Math.random() * 20;
        const points = generateAnchorPoints(baseR, 6);
        return {
          id: 'Node' + i,
          r: baseR,
          points,
        };
      });

      const width = 800;
      const height = 600;

      const svg = d3.select('#viz');

      const simulation = d3
        .forceSimulation(data)
        .force('charge', d3.forceManyBody().strength(5))
        .force('center', d3.forceCenter(width / 2, height / 2))
        .force(
          'collision',
          d3.forceCollide().radius(d => d.r + 2),
        );

      const nodeGroup = svg.selectAll('g.node').data(data).join('g').attr('class', 'node');

      // The path (dragging this moves entire node)
      nodeGroup
        .append('path')
        .attr('fill', (_, i) => d3.schemeTableau10[i % 10])
        .attr('stroke', '#333')
        .attr('stroke-width', 1)
        .call(
          d3
            .drag()
            .on('start', (event, anchorData) => {
              if (!event.active) simulation.alphaTarget(0.3).restart();

              // Convert the anchor’s existing local offset to *global* so we know where it is now
              const oldGlobalX = anchorData.parent.x + anchorData.pt[0];
              const oldGlobalY = anchorData.parent.y + anchorData.pt[1];

              // Shift the anchor so that (event.x, event.y) lines up
              anchorData.pt[0] = oldGlobalX - event.x;
              anchorData.pt[1] = oldGlobalY - event.y;
            })
            .on('drag', (event, anchorData) => {
              // Now as the mouse moves, we keep adjusting local coords
              // so anchor matches the new global mouse position
              anchorData.pt[0] = anchorData.pt[0] + event.dx;
              anchorData.pt[1] = anchorData.pt[1] + event.dy;

              anchorData.parent.r = maxDistanceFromCenter(anchorData.parent.points);

              d3.select(this.parentNode).select('path').attr('d', generateBlobPath(anchorData.parent.points));

              simulation.alpha(1).restart();
            })
            .on('end', (event, d) => {
              if (!event.active) simulation.alphaTarget(0);
              d.fx = null;
              d.fy = null;
            }),
        );

      // The anchor points (dragging these deforms shape)
      nodeGroup
        .selectAll('circle.anchor')
        .data(d => d.points.map(pt => ({ parent: d, pt })))
        .join('circle')
        .attr('class', 'anchor')
        .attr('r', 4)
        .call(
          d3
            .drag()
            .on('start', (event, anchorData) => {
              if (!event.active) simulation.alphaTarget(0.3).restart();
            })
            .on('drag', (event, anchorData) => {
              // Move anchor by the mouse’s delta
              anchorData.pt[0] += event.dx;
              anchorData.pt[1] += event.dy;

              // Recompute bounding radius
              anchorData.parent.r = maxDistanceFromCenter(anchorData.parent.points);

              // Re-draw the path in real-time
              d3.select(event.sourceEvent.target.parentNode).select('path').attr('d', generateBlobPath(anchorData.parent.points));

              simulation.alpha(1).restart();
            })
            .on('end', (event, anchorData) => {
              if (!event.active) simulation.alphaTarget(0);
            }),
        );

      // On each tick, position groups
      simulation.on('tick', () => {
        nodeGroup.attr('transform', d => `translate(${d.x}, ${d.y})`);

        nodeGroup.select('path').attr('d', d => generateBlobPath(d.points));

        nodeGroup
          .selectAll('circle.anchor')
          .attr('cx', d => d.pt[0])
          .attr('cy', d => d.pt[1]);
      });

      // Helpers
      function generateAnchorPoints(baseR, count = 6) {
        const angleStep = (Math.PI * 2) / count;
        const points = [];
        for (let i = 0; i < count; i++) {
          const angle = i * angleStep;
          const r = baseR * (1 + Math.random() * 0.3 - 0.15);
          points.push([Math.cos(angle) * r, Math.sin(angle) * r]);
        }
        return points;
      }

      function generateBlobPath(points) {
        return d3.line().curve(d3.curveCardinalClosed)(points);
      }

      function maxDistanceFromCenter(points) {
        let maxDist = 0;
        points.forEach(([x, y]) => {
          const dist = Math.sqrt(x * x + y * y);
          if (dist > maxDist) maxDist = dist;
        });
        return maxDist;
      }
    </script>
  </body>
</html>
